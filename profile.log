SCRIPT  /Users/rossdavis/.vim/plugs/ale/autoload/ale/engine.vim
Sourced 1 time
Total time:   0.000866
 Self time:   0.000866

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Backend execution and job management
                            "   Executes linters in the background, using NeoVim or Vim 8 jobs
                            
                            " Stores information for each job including:
                            "
                            " linter: The linter dictionary for the job.
                            " buffer: The buffer number for the job.
                            " output: The array of lines for the output of the job.
    1              0.000007 if !has_key(s:, 'job_info_map')
    1              0.000004     let s:job_info_map = {}
    1              0.000001 endif
                            
                            " Associates LSP connection IDs with linter names.
    1              0.000003 if !has_key(s:, 'lsp_linter_map')
    1              0.000007     let s:lsp_linter_map = {}
    1              0.000001 endif
                            
    1              0.000003 if !has_key(s:, 'executable_cache_map')
    1              0.000002     let s:executable_cache_map = {}
    1              0.000001 endif
                            
    1              0.000006 function! ale#engine#ResetExecutableCache() abort
                                let s:executable_cache_map = {}
                            endfunction
                            
                            " Check if files are executable, and if they are, remember that they are
                            " for subsequent calls. We'll keep checking until programs can be executed.
    1              0.000004 function! ale#engine#IsExecutable(buffer, executable) abort
                                if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                if has_key(s:executable_cache_map, a:executable)
                                    return 1
                                endif
                            
                                let l:result = 0
                            
                                if executable(a:executable)
                                    let s:executable_cache_map[a:executable] = 1
                            
                                    let l:result = 1
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
                                endif
                            
                                return l:result
                            endfunction
                            
    1              0.000004 function! ale#engine#InitBufferInfo(buffer) abort
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of job IDs
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
                                    let g:ale_buffer_info[a:buffer] = {
                                    \   'job_list': [],
                                    \   'active_linter_list': [],
                                    \   'loclist': [],
                                    \   'temporary_file_list': [],
                                    \   'temporary_directory_list': [],
                                    \}
                            
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " Return 1 if ALE is busy checking a given buffer
    1              0.000002 function! ale#engine#IsCheckingBuffer(buffer) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                return !empty(get(l:info, 'active_linter_list', []))
                            endfunction
                            
                            " Register a temporary file to be managed with the ALE engine for
                            " a current job run.
    1              0.000004 function! ale#engine#ManageFile(buffer, filename) abort
                                call add(g:ale_buffer_info[a:buffer].temporary_file_list, a:filename)
                            endfunction
                            
                            " Same as the above, but manage an entire directory.
    1              0.000003 function! ale#engine#ManageDirectory(buffer, directory) abort
                                call add(g:ale_buffer_info[a:buffer].temporary_directory_list, a:directory)
                            endfunction
                            
                            " Create a new temporary directory and manage it in one go.
    1              0.000002 function! ale#engine#CreateDirectory(buffer) abort
                                let l:temporary_directory = tempname()
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
                                call mkdir(l:temporary_directory, '', 0750)
                                call ale#engine#ManageDirectory(a:buffer, l:temporary_directory)
                            
                                return l:temporary_directory
                            endfunction
                            
    1              0.000002 function! ale#engine#RemoveManagedFiles(buffer) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
                                if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
                                if has_key(l:info, 'temporary_file_list')
                                    for l:filename in l:info.temporary_file_list
                                        call delete(l:filename)
                                    endfor
                            
                                    let l:info.temporary_file_list = []
                                endif
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
                                if has_key(l:info, 'temporary_directory_list')
                                    for l:directory in l:info.temporary_directory_list
                                        call delete(l:directory, 'rf')
                                    endfor
                            
                                    let l:info.temporary_directory_list = []
                                endif
                            endfunction
                            
    1              0.000003 function! s:GatherOutput(job_id, line) abort
                                if has_key(s:job_info_map, a:job_id)
                                    call add(s:job_info_map[a:job_id].output, a:line)
                                endif
                            endfunction
                            
    1              0.000002 function! s:HandleLoclist(linter_name, buffer, loclist) abort
                                let l:buffer_info = get(g:ale_buffer_info, a:buffer, {})
                            
                                if empty(l:buffer_info)
                                    return
                                endif
                            
                                " Remove this linter from the list of active linters.
                                " This may have already been done when the job exits.
                                call filter(l:buffer_info.active_linter_list, 'v:val isnot# a:linter_name')
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
                                let l:linter_loclist = ale#engine#FixLocList(a:buffer, a:linter_name, a:loclist)
                            
                                " Remove previous items for this linter.
                                call filter(g:ale_buffer_info[a:buffer].loclist, 'v:val.linter_name isnot# a:linter_name')
                                " Add the new items.
                                call extend(g:ale_buffer_info[a:buffer].loclist, l:linter_loclist)
                            
                                " Sort the loclist again.
                                " We need a sorted list so we can run a binary search against it
                                " for efficient lookup of the messages in the cursor handler.
                                call sort(g:ale_buffer_info[a:buffer].loclist, 'ale#util#LocItemCompare')
                            
                                if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                call ale#engine#SetResults(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                            endfunction
                            
    1              0.000002 function! s:HandleExit(job_id, exit_code) abort
                                if !has_key(s:job_info_map, a:job_id)
                                    return
                                endif
                            
                                let l:job_info = s:job_info_map[a:job_id]
                                let l:linter = l:job_info.linter
                                let l:output = l:job_info.output
                                let l:buffer = l:job_info.buffer
                                let l:next_chain_index = l:job_info.next_chain_index
                            
                                if g:ale_history_enabled
                                    call ale#history#SetExitCode(l:buffer, a:job_id, a:exit_code)
                                endif
                            
                                " Remove this job from the list.
                                call ale#job#Stop(a:job_id)
                                call remove(s:job_info_map, a:job_id)
                                call filter(g:ale_buffer_info[l:buffer].job_list, 'v:val isnot# a:job_id')
                                call filter(g:ale_buffer_info[l:buffer].active_linter_list, 'v:val isnot# l:linter.name')
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
                                if ale#util#InSandbox()
                                    return
                                endif
                            
                                if has('nvim') && !empty(l:output) && empty(l:output[-1])
                                    call remove(l:output, -1)
                                endif
                            
                                if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    call s:InvokeChain(l:buffer, l:linter, l:next_chain_index, l:output)
                                    return
                                endif
                            
                                " Log the output of the command for ALEInfo if we should.
                                if g:ale_history_enabled && g:ale_history_log_output
                                    call ale#history#RememberOutput(l:buffer, a:job_id, l:output[:])
                                endif
                            
                                let l:loclist = ale#util#GetFunction(l:linter.callback)(l:buffer, l:output)
                            
                                call s:HandleLoclist(l:linter.name, l:buffer, l:loclist)
                            endfunction
                            
    1              0.000002 function! s:HandleLSPDiagnostics(conn_id, response) abort
                                let l:linter_name = s:lsp_linter_map[a:conn_id]
                                let l:filename = ale#path#FromURI(a:response.params.uri)
                                let l:buffer = bufnr(l:filename)
                            
                                if l:buffer <= 0
                                    return
                                endif
                            
                                let l:loclist = ale#lsp#response#ReadDiagnostics(a:response)
                            
                                call s:HandleLoclist(l:linter_name, l:buffer, l:loclist)
                            endfunction
                            
    1              0.000002 function! s:HandleTSServerDiagnostics(response, error_type) abort
                                let l:buffer = bufnr(a:response.body.file)
                                let l:info = get(g:ale_buffer_info, l:buffer, {})
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                let l:thislist = ale#lsp#response#ReadTSServerDiagnostics(a:response)
                            
                                " tsserver sends syntax and semantic errors in separate messages, so we
                                " have to collect the messages separately for each buffer and join them
                                " back together again.
                                if a:error_type is# 'syntax'
                                    let l:info.syntax_loclist = l:thislist
                                else
                                    let l:info.semantic_loclist = l:thislist
                                endif
                            
                                let l:loclist = get(l:info, 'semantic_loclist', [])
                                \   + get(l:info, 'syntax_loclist', [])
                            
                                call s:HandleLoclist('tsserver', l:buffer, l:loclist)
                            endfunction
                            
    1              0.000002 function! s:HandleLSPErrorMessage(error_message) abort
                                execute 'echoerr ''Error from LSP:'''
                            
                                for l:line in split(a:error_message, "\n")
                                    execute 'echoerr l:line'
                                endfor
                            endfunction
                            
    1              0.000003 function! ale#engine#HandleLSPResponse(conn_id, response) abort
                                let l:method = get(a:response, 'method', '')
                            
                                if get(a:response, 'jsonrpc', '') is# '2.0' && has_key(a:response, 'error')
                                    " Uncomment this line to print LSP error messages.
                                    " call s:HandleLSPErrorMessage(a:response.error.message)
                                elseif l:method is# 'textDocument/publishDiagnostics'
                                    call s:HandleLSPDiagnostics(a:conn_id, a:response)
                                elseif get(a:response, 'type', '') is# 'event'
                                \&& get(a:response, 'event', '') is# 'semanticDiag'
                                    call s:HandleTSServerDiagnostics(a:response, 'semantic')
                                elseif get(a:response, 'type', '') is# 'event'
                                \&& get(a:response, 'event', '') is# 'syntaxDiag'
                                    call s:HandleTSServerDiagnostics(a:response, 'syntax')
                                endif
                            endfunction
                            
    1              0.000003 function! ale#engine#SetResults(buffer, loclist) abort
                                let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
                                if g:ale_set_signs
                                    call ale#sign#SetSigns(a:buffer, a:loclist)
                                endif
                            
                                if g:ale_set_quickfix || g:ale_set_loclist
                                    call ale#list#SetLists(a:buffer, a:loclist)
                                endif
                            
                                if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
                                endif
                            
                                if g:ale_set_highlights
                                    call ale#highlight#SetHighlights(a:buffer, a:loclist)
                                endif
                            
                                if g:ale_echo_cursor
                                    " Try and echo the warning now.
                                    " This will only do something meaningful if we're in normal mode.
                                    call ale#cursor#EchoCursorWarning()
                                endif
                            
                                if l:linting_is_done
                                    " Reset the save event marker, used for opening windows, etc.
                                    call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
                                    call ale#engine#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
                                    silent doautocmd <nomodeline> User ALELint
                                endif
                            endfunction
                            
    1              0.000002 function! s:RemapItemTypes(type_map, loclist) abort
                                for l:item in a:loclist
                                    let l:key = l:item.type
                                    \   . (get(l:item, 'sub_type', '') is# 'style' ? 'S' : '')
                                    let l:new_key = get(a:type_map, l:key, '')
                            
                                    if l:new_key is# 'E'
                                    \|| l:new_key is# 'ES'
                                    \|| l:new_key is# 'W'
                                    \|| l:new_key is# 'WS'
                                    \|| l:new_key is# 'I'
                                        let l:item.type = l:new_key[0]
                            
                                        if l:new_key is# 'ES' || l:new_key is# 'WS'
                                            let l:item.sub_type = 'style'
                                        elseif has_key(l:item, 'sub_type')
                                            call remove(l:item, 'sub_type')
                                        endif
                                    endif
                                endfor
                            endfunction
                            
                            " Save the temporary directory so we can figure out if files are in it.
    1              0.000008 let s:temp_dir = fnamemodify(tempname(), ':h')
                            
    1              0.000004 function! ale#engine#FixLocList(buffer, linter_name, loclist) abort
                                let l:bufnr_map = {}
                                let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
                                let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
                                for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
                                    let l:item = {
                                    \   'bufnr': a:buffer,
                                    \   'text': l:old_item.text,
                                    \   'lnum': str2nr(l:old_item.lnum),
                                    \   'col': str2nr(get(l:old_item, 'col', 0)),
                                    \   'vcol': get(l:old_item, 'vcol', 0),
                                    \   'type': get(l:old_item, 'type', 'E'),
                                    \   'nr': get(l:old_item, 'nr', -1),
                                    \   'linter_name': a:linter_name,
                                    \}
                            
                                    if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
                                    endif
                            
                                    if has_key(l:old_item, 'filename')
                                    \&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
                                    if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
                                    if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
                                    if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
                                    if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
                                    if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    endif
                            
                                    call add(l:new_loclist, l:item)
                                endfor
                            
                                let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
                                if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
                                return l:new_loclist
                            endfunction
                            
                            " Given part of a command, replace any % with %%, so that no characters in
                            " the string will be replaced with filenames, etc.
    1              0.000003 function! ale#engine#EscapeCommandPart(command_part) abort
                                return substitute(a:command_part, '%', '%%', 'g')
                            endfunction
                            
    1              0.000002 function! s:CreateTemporaryFileForJob(buffer, temporary_file) abort
                                if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
                                endif
                            
                                let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
                                call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
                                call ale#engine#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
                                let l:lines = getbufline(a:buffer, 1, '$')
                                call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
                                return 1
                            endfunction
                            
                            " Run a job.
                            "
                            " Returns 1 when the job was started successfully.
    1              0.000002 function! s:RunJob(options) abort
                                let l:command = a:options.command
                                let l:buffer = a:options.buffer
                                let l:linter = a:options.linter
                                let l:output_stream = a:options.output_stream
                                let l:next_chain_index = a:options.next_chain_index
                                let l:read_buffer = a:options.read_buffer
                                let l:info = g:ale_buffer_info[l:buffer]
                            
                                if empty(l:command)
                                    return 0
                                endif
                            
                                let [l:temporary_file, l:command] = ale#command#FormatCommand(l:buffer, l:command, l:read_buffer)
                            
                                if s:CreateTemporaryFileForJob(l:buffer, l:temporary_file)
                                    " If a temporary filename has been formatted in to the command, then
                                    " we do not need to send the Vim buffer to the command.
                                    let l:read_buffer = 0
                                endif
                            
                                " Add a newline to commands which need it.
                                " This is only used for Flow for now, and is not documented.
                                if l:linter.add_newline
                                    if has('win32')
                                        let l:command = l:command . '; echo.'
                                    else
                                        let l:command = l:command . '; echo'
                                    endif
                                endif
                            
                                let l:command = ale#job#PrepareCommand(l:command)
                                let l:job_options = {
                                \   'mode': 'nl',
                                \   'exit_cb': function('s:HandleExit'),
                                \}
                            
                                if l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput')
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                else
                                    let l:job_options.out_cb = function('s:GatherOutput')
                                endif
                            
                                if get(g:, 'ale_run_synchronously') == 1
                                    " Find a unique Job value to use, which will be the same as the ID for
                                    " running commands synchronously. This is only for test code.
                                    let l:job_id = len(s:job_info_map) + 1
                            
                                    while has_key(s:job_info_map, l:job_id)
                                        let l:job_id += 1
                                    endwhile
                                else
                                    let l:job_id = ale#job#Start(l:command, l:job_options)
                                endif
                            
                                let l:status = 'failed'
                            
                                " Only proceed if the job is being run.
                                if l:job_id
                                    " Add the job to the list of jobs, so we can track them.
                                    call add(l:info.job_list, l:job_id)
                            
                                    if index(l:info.active_linter_list, l:linter.name) < 0
                                        call add(l:info.active_linter_list, l:linter.name)
                                    endif
                            
                                    let l:status = 'started'
                                    " Store the ID for the job in the map to read back again.
                                    let s:job_info_map[l:job_id] = {
                                    \   'linter': l:linter,
                                    \   'buffer': l:buffer,
                                    \   'output': [],
                                    \   'next_chain_index': l:next_chain_index,
                                    \}
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(l:buffer, l:status, l:job_id, l:command)
                                endif
                            
                                if get(g:, 'ale_run_synchronously') == 1
                                    " Run a command synchronously if this test option is set.
                                    let s:job_info_map[l:job_id].output = systemlist(
                                    \   type(l:command) == type([])
                                    \   ?  join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])
                                    \   : l:command
                                    \)
                            
                                    call l:job_options.exit_cb(l:job_id, v:shell_error)
                                endif
                            
                                return l:job_id != 0
                            endfunction
                            
                            " Determine which commands to run for a link in a command chain, or
                            " just a regular command.
    1              0.000004 function! ale#engine#ProcessChain(buffer, linter, chain_index, input) abort
                                let l:output_stream = get(a:linter, 'output_stream', 'stdout')
                                let l:read_buffer = a:linter.read_buffer
                                let l:chain_index = a:chain_index
                                let l:input = a:input
                            
                                if has_key(a:linter, 'command_chain')
                                    while l:chain_index < len(a:linter.command_chain)
                                        " Run a chain of commands, one asynchronous command after the other,
                                        " so that many programs can be run in a sequence.
                                        let l:chain_item = a:linter.command_chain[l:chain_index]
                            
                                        if l:chain_index == 0
                                            " The first callback in the chain takes only a buffer number.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(
                                            \   a:buffer
                                            \)
                                        else
                                            " The second callback in the chain takes some input too.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(
                                            \   a:buffer,
                                            \   l:input
                                            \)
                                        endif
                            
                                        if !empty(l:command)
                                            " We hit a command to run, so we'll execute that
                            
                                            " The chain item can override the output_stream option.
                                            if has_key(l:chain_item, 'output_stream')
                                                let l:output_stream = l:chain_item.output_stream
                                            endif
                            
                                            " The chain item can override the read_buffer option.
                                            if has_key(l:chain_item, 'read_buffer')
                                                let l:read_buffer = l:chain_item.read_buffer
                                            elseif l:chain_index != len(a:linter.command_chain) - 1
                                                " Don't read the buffer for commands besides the last one
                                                " in the chain by default.
                                                let l:read_buffer = 0
                                            endif
                            
                                            break
                                        endif
                            
                                        " Command chain items can return an empty string to indicate that
                                        " a command should be skipped, so we should try the next item
                                        " with no input.
                                        let l:input = []
                                        let l:chain_index += 1
                                    endwhile
                                else
                                    let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                                endif
                            
                                return {
                                \   'command': l:command,
                                \   'buffer': a:buffer,
                                \   'linter': a:linter,
                                \   'output_stream': l:output_stream,
                                \   'next_chain_index': l:chain_index + 1,
                                \   'read_buffer': l:read_buffer,
                                \}
                            endfunction
                            
    1              0.000003 function! s:InvokeChain(buffer, linter, chain_index, input) abort
                                let l:options = ale#engine#ProcessChain(a:buffer, a:linter, a:chain_index, a:input)
                            
                                return s:RunJob(l:options)
                            endfunction
                            
    1              0.000002 function! s:StopCurrentJobs(buffer, include_lint_file_jobs) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                                let l:new_job_list = []
                                let l:new_active_linter_list = []
                            
                                for l:job_id in get(l:info, 'job_list', [])
                                    let l:job_info = get(s:job_info_map, l:job_id, {})
                            
                                    if !empty(l:job_info)
                                        if a:include_lint_file_jobs || !l:job_info.linter.lint_file
                                            call ale#job#Stop(l:job_id)
                                            call remove(s:job_info_map, l:job_id)
                                        else
                                            call add(l:new_job_list, l:job_id)
                                            " Linters with jobs still running are still active.
                                            call add(l:new_active_linter_list, l:job_info.linter.name)
                                        endif
                                    endif
                                endfor
                            
                                " Remove duplicates from the active linter list.
                                call uniq(sort(l:new_active_linter_list))
                            
                                " Update the List, so it includes only the jobs we still need.
                                let l:info.job_list = l:new_job_list
                                " Update the active linter list, clearing out anything not running.
                                let l:info.active_linter_list = l:new_active_linter_list
                            endfunction
                            
    1              0.000002 function! s:CheckWithLSP(buffer, linter) abort
                                let l:info = g:ale_buffer_info[a:buffer]
                                let l:lsp_details = ale#linter#StartLSP(
                                \   a:buffer,
                                \   a:linter,
                                \   function('ale#engine#HandleLSPResponse'),
                                \)
                            
                                if empty(l:lsp_details)
                                    return 0
                                endif
                            
                                let l:id = l:lsp_details.connection_id
                                let l:root = l:lsp_details.project_root
                            
                                " Remember the linter this connection is for.
                                let s:lsp_linter_map[l:id] = a:linter.name
                            
                                let l:change_message = a:linter.lsp is# 'tsserver'
                                \   ? ale#lsp#tsserver_message#Geterr(a:buffer)
                                \   : ale#lsp#message#DidChange(a:buffer)
                                let l:request_id = ale#lsp#Send(l:id, l:change_message, l:root)
                            
                                if l:request_id != 0
                                    if index(l:info.active_linter_list, a:linter.name) < 0
                                        call add(l:info.active_linter_list, a:linter.name)
                                    endif
                                endif
                            
                                return l:request_id != 0
                            endfunction
                            
    1              0.000003 function! s:RemoveProblemsForDisabledLinters(buffer, linters) abort
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                let l:name_map = {}
                            
                                for l:linter in a:linters
                                    let l:name_map[l:linter.name] = 1
                                endfor
                            
                                call filter(
                                \   get(g:ale_buffer_info[a:buffer], 'loclist', []),
                                \   'get(l:name_map, get(v:val, ''linter_name''))',
                                \)
                            endfunction
                            
    1              0.000003 function! s:AddProblemsFromOtherBuffers(buffer, linters) abort
                                let l:filename = expand('#' . a:buffer . ':p')
                                let l:loclist = []
                                let l:name_map = {}
                            
                                " Build a map of the active linters.
                                for l:linter in a:linters
                                    let l:name_map[l:linter.name] = 1
                                endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
                                for l:info in values(g:ale_buffer_info)
                                    for l:item in l:info.loclist
                                        if has_key(l:item, 'filename')
                                        \&& l:item.filename is# l:filename
                                        \&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
                                        endif
                                    endfor
                                endfor
                            
                                if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
                                endif
                            endfunction
                            
                            " Run a linter for a buffer.
                            "
                            " Returns 1 if the linter was successfully run.
    1              0.000002 function! s:RunLinter(buffer, linter) abort
                                if !empty(a:linter.lsp)
                                    return s:CheckWithLSP(a:buffer, a:linter)
                                else
                                    let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
                                    if ale#engine#IsExecutable(a:buffer, l:executable)
                                        return s:InvokeChain(a:buffer, a:linter, 0, [])
                                    endif
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000004 function! ale#engine#RunLinters(buffer, linters, should_lint_file) abort
                                " Initialise the buffer information if needed.
                                let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                                call s:StopCurrentJobs(a:buffer, a:should_lint_file)
                                call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
                                let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                for l:linter in a:linters
                                    " Only run lint_file linters if we should.
                                    if !l:linter.lint_file || a:should_lint_file
                                        if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
                                            let l:can_clear_results = 0
                                        endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
                                endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
                                if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif
                            endfunction
                            
                            " Clean up a buffer.
                            "
                            " This function will stop all current jobs for the buffer,
                            " clear the state of everything, and remove the Dictionary for managing
                            " the buffer.
    1              0.000003 function! ale#engine#Cleanup(buffer) abort
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
                                if get(v:, 'exiting', v:null) isnot v:null
                                    return
                                endif
                            
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
                                call ale#engine#RunLinters(a:buffer, [], 1)
                            
                                call remove(g:ale_buffer_info, a:buffer)
                            endfunction
                            
                            " Given a buffer number, return the warnings and errors for a given buffer.
    1              0.000003 function! ale#engine#GetLoclist(buffer) abort
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    return []
                                endif
                            
                                return g:ale_buffer_info[a:buffer].loclist
                            endfunction
                            
                            " This function can be called with a timeout to wait for all jobs to finish.
                            " If the jobs to not finish in the given number of milliseconds,
                            " an exception will be thrown.
                            "
                            " The time taken will be a very rough approximation, and more time may be
                            " permitted than is specified.
    1              0.000003 function! ale#engine#WaitForJobs(deadline) abort
                                let l:start_time = ale#util#ClockMilliseconds()
                            
                                if l:start_time == 0
                                    throw 'Failed to read milliseconds from the clock!'
                                endif
                            
                                let l:job_list = []
                            
                                " Gather all of the jobs from every buffer.
                                for l:info in values(g:ale_buffer_info)
                                    call extend(l:job_list, get(l:info, 'job_list', []))
                                endfor
                            
                                " NeoVim has a built-in API for this, so use that.
                                if has('nvim')
                                    let l:nvim_code_list = jobwait(l:job_list, a:deadline)
                            
                                    if index(l:nvim_code_list, -1) >= 0
                                        throw 'Jobs did not complete on time!'
                                    endif
                            
                                    return
                                endif
                            
                                let l:should_wait_more = 1
                            
                                while l:should_wait_more
                                    let l:should_wait_more = 0
                            
                                    for l:job_id in l:job_list
                                        if ale#job#IsRunning(l:job_id)
                                            let l:now = ale#util#ClockMilliseconds()
                            
                                            if l:now - l:start_time > a:deadline
                                                " Stop waiting after a timeout, so we don't wait forever.
                                                throw 'Jobs did not complete on time!'
                                            endif
                            
                                            " Wait another 10 milliseconds
                                            let l:should_wait_more = 1
                                            sleep 10ms
                                            break
                                        endif
                                    endfor
                                endwhile
                            
                                " Sleep for a small amount of time after all jobs finish.
                                " This seems to be enough to let handlers after jobs end run, and
                                " prevents the occasional failure where this function exits after jobs
                                " end, but before handlers are run.
                                sleep 10ms
                            
                                " We must check the buffer data again to see if new jobs started
                                " for command_chain linters.
                                let l:has_new_jobs = 0
                            
                                " Check again to see if any jobs are running.
                                for l:info in values(g:ale_buffer_info)
                                    for l:job_id in get(l:info, 'job_list', [])
                                        if ale#job#IsRunning(l:job_id)
                                            let l:has_new_jobs = 1
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                if l:has_new_jobs
                                    " We have to wait more. Offset the timeout by the time taken so far.
                                    let l:now = ale#util#ClockMilliseconds()
                                    let l:new_deadline = a:deadline - (l:now - l:start_time)
                            
                                    if l:new_deadline <= 0
                                        " Enough time passed already, so stop immediately.
                                        throw 'Jobs did not complete on time!'
                                    endif
                            
                                    call ale#engine#WaitForJobs(l:new_deadline)
                                endif
                            endfunction

SCRIPT  /Users/rossdavis/.vim/plugs/ctrlp.vim/autoload/ctrlp/utils.vim
Sourced 1 time
Total time:   0.000273
 Self time:   0.000147

count  total (s)   self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp/utils.vim
                            " Description:   Utilities
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            
                            " Static variables {{{1
    1              0.000005 fu! ctrlp#utils#lash()
                            	retu &ssl || !exists('+ssl') ? '/' : '\'
                            endf
                            
    1              0.000002 fu! s:lash(...)
                            	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
                            endf
                            
    1              0.000002 fu! ctrlp#utils#opts()
                            	let s:lash = ctrlp#utils#lash()
                            	let usrhome = $HOME . s:lash( $HOME )
                            	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
                            	let cadir = isdirectory(usrhome.'.ctrlp_cache')
                            		\ ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
                            	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
                            	let s:cache_dir = cadir
                            endf
    1   0.000140   0.000014 cal ctrlp#utils#opts()
                            
    1              0.000004 let s:wig_cond = v:version > 702 || ( v:version == 702 && has('patch051') )
                            " Files and Directories {{{1
    1              0.000003 fu! ctrlp#utils#cachedir()
                            	retu s:cache_dir
                            endf
                            
    1              0.000002 fu! ctrlp#utils#cachefile(...)
                            	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
                            	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
                            	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file
                            endf
                            
    1              0.000002 fu! ctrlp#utils#readfile(file)
                            	if filereadable(a:file)
                            		let data = readfile(a:file)
                            		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
                            		retu data
                            	en
                            	retu []
                            endf
                            
    1              0.000003 fu! ctrlp#utils#mkdir(dir)
                            	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
                            	retu a:dir
                            endf
                            
    1              0.000003 fu! ctrlp#utils#writecache(lines, ...)
                            	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
                            		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
                            	en
                            endf
                            
    1              0.000002 fu! ctrlp#utils#glob(...)
                            	let path = ctrlp#utils#fnesc(a:1, 'g')
                            	retu s:wig_cond ? glob(path, a:2) : glob(path)
                            endf
                            
    1              0.000002 fu! ctrlp#utils#globpath(...)
                            	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])
                            endf
                            
    1              0.000003 fu! ctrlp#utils#fnesc(path, type, ...)
                            	if exists('*fnameescape')
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = fnameescape(a:path)
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = fnameescape(a:path)
                            		en
                            	el
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = escape(a:path, " \t\n%#*?|<\"")
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                            		en
                            	en
                            	retu a:0 ? escape(path, a:1) : path
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

FUNCTION  <SNR>37_repo_head_ref()
Called 4 times
Total time:   0.000416
 Self time:   0.000339

count  total (s)   self (s)
    4   0.000194   0.000157   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
    4   0.000204   0.000164   return readfile(self.dir('HEAD'))[0]

FUNCTION  <SNR>90_update_git_branch()
Called 4 times
Total time:   0.001392
 Self time:   0.000265

count  total (s)   self (s)
    4              0.000008   if !s:has_fugitive
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
    4   0.001162   0.000035   let name = fugitive#head(7)
    4              0.000012   if empty(name)
                                if has_key(s:git_dirs, a:path)
                                  let s:vcs_config['git'].branch = s:git_dirs[a:path]
                                  return
                                endif
                            
                                let dir = fugitive#extract_git_dir(a:path)
                                if empty(dir)
                                  let name = ''
                                else
                                  try
                                    let line = join(readfile(dir . '/HEAD'))
                                    if strpart(line, 0, 16) == 'ref: refs/heads/'
                                      let name = strpart(line, 16)
                                    else
                                      " raw commit hash
                                      let name = strpart(line, 0, 7)
                                    endif
                                  catch
                                    let name = ''
                                  endtry
                                endif
                              endif
                            
    4              0.000019   let s:git_dirs[a:path] = name
    4              0.000015   let s:vcs_config['git'].branch = name

FUNCTION  airline#statusline()
Called 4 times
Total time:   0.000203
 Self time:   0.000203

count  total (s)   self (s)
    4              0.000134   if has_key(s:contexts, a:winnr)
    4              0.000055     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
Called 4 times
Total time:   0.000629
 Self time:   0.000629

count  total (s)   self (s)
    4              0.000025   let context = s:contexts[a:winnr]
                            
    4              0.000021   if get(w:, 'airline_active', 1)
    4              0.000018     let l:m = mode()
    4              0.000013     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
    4              0.000013       let l:mode = ['normal']
    4              0.000006     endif
    4              0.000032     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
    4              0.000005   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
    4              0.000021   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
    4              0.000012   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
    4              0.000029   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
    4              0.000011   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
    4              0.000009   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
    4              0.000035   let mode_string = join(l:mode)
    4              0.000025   if get(w:, 'airline_lastmode', '') != mode_string
                                call airline#highlighter#highlight_modified_inactive(context.bufnr)
                                call airline#highlighter#highlight(l:mode, context.bufnr)
                                let w:airline_lastmode = mode_string
                              endif
                            
    4              0.000007   return ''

FUNCTION  <SNR>37_repo()
Called 8 times
Total time:   0.000279
 Self time:   0.000279

count  total (s)   self (s)
    8              0.000075   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
    8              0.000013   if dir !=# ''
    8              0.000028     if has_key(s:repos, dir)
    8              0.000026       let repo = get(s:repos, dir)
    8              0.000008     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
    8              0.000071     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  gitgutter#hunk#reset()
Called 2 times
Total time:   0.000237
 Self time:   0.000102

count  total (s)   self (s)
    2   0.000126   0.000070   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', [])
    2   0.000110   0.000031   call s:reset_summary()

FUNCTION  airline#util#append()
Called 28 times
Total time:   0.000409
 Self time:   0.000409

count  total (s)   self (s)
   28              0.000084   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   28              0.000124   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   28              0.000114   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  ctrlp#utils#writecache()
Called 1 time
Total time:   0.001173
 Self time:   0.001153

count  total (s)   self (s)
    1   0.000040   0.000020 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    1              0.001129 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    1              0.000002 	en

FUNCTION  ale#statusline#Count()
Called 8 times
Total time:   0.000287
 Self time:   0.000095

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
    8   0.000277   0.000085     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>90_update_untracked()
Called 4 times
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
    4              0.000152   let file = expand("%:p")
    4              0.000019   if empty(file) || isdirectory(file)
    4              0.000004     return
                              endif
                            
                              let needs_update = 1
                              for vcs in keys(s:vcs_config)
                                if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
                                if has_key(s:vcs_config[vcs].untracked, file)
                                  let needs_update = 0
                                  call airline#extensions#branch#update_untracked_config(file, vcs)
                                endif
                              endfor
                            
                              if !needs_update
                                return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                let config = s:vcs_config[vcs]
                                if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  call airline#async#vim_vcs_untracked(config, file)
                                else
                                  " nvim async or vim without job-feature
                                  call airline#async#nvim_vcs_untracked(config, file, vcs)
                                endif
                              endfor

FUNCTION  airline#parts#filetype()
Called 4 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    4              0.000031   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#parts#iminsert()
Called 4 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    4              0.000015   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
    4              0.000005   return ''

FUNCTION  <SNR>112_reset_summary()
Called 2 times
Total time:   0.000079
 Self time:   0.000036

count  total (s)   self (s)
    2   0.000077   0.000034   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'summary', [0,0,0])

FUNCTION  gitgutter#utility#use_known_shell()
Called 2 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    2              0.000010   if has('unix')
    2              0.000010     if &shell !=# 'sh'
    2              0.000007       let s:shell = &shell
    2              0.000007       let s:shellcmdflag = &shellcmdflag
    2              0.000006       let s:shellredir = &shellredir
    2              0.000015       let &shell = 'sh'
    2              0.000016       set shellcmdflag=-c
    2              0.000008       set shellredir=>%s\ 2>&1
    2              0.000002     endif
    2              0.000003   endif

FUNCTION  gitgutter#process_buffer()
Called 2 times
Total time:   0.000823
 Self time:   0.000283

count  total (s)   self (s)
    2   0.000133   0.000042   call gitgutter#utility#use_known_shell()
                            
    2   0.000080   0.000043   call gitgutter#utility#set_buffer(a:bufnr)
    2   0.000155   0.000039   if gitgutter#utility#is_active()
                                if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
                                try
                                  if !a:realtime || gitgutter#utility#has_fresh_changes()
                                    let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 0)
                                    if diff != 'async'
                                      call gitgutter#handle_diff(diff)
                                    endif
                                  endif
                                catch /diff failed/
                                  call gitgutter#debug#log('diff failed')
                                  call gitgutter#hunk#reset()
                                endtry
                                execute "silent doautocmd" s:nomodeline "User GitGutter"
                              else
    2   0.000269   0.000032     call gitgutter#hunk#reset()
    2              0.000002   endif
                            
    2   0.000096   0.000037   call gitgutter#utility#restore_shell()

FUNCTION  gitgutter#hunk#summary()
Called 4 times
Total time:   0.000119
 Self time:   0.000055

count  total (s)   self (s)
    4   0.000118   0.000054   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>45_SendHeartbeats()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000008         let start_time = localtime()
    1              0.000002         let stdout = ''
                            
    1              0.000005         if len(s:heartbeats_buffer) == 0
    1              0.000003             let s:last_sent = start_time
    1              0.000002             return
                                    endif
                            
                                    let heartbeat = s:heartbeats_buffer[0]
                                    let s:heartbeats_buffer = s:heartbeats_buffer[1:-1]
                                    if len(s:heartbeats_buffer) > 0
                                        let extra_heartbeats = s:GetHeartbeatsJson()
                                    else
                                        let extra_heartbeats = ''
                                    endif
                            
                                    let python_bin = g:wakatime_PythonBinary
                                    if s:IsWindows()
                                        if python_bin == 'python'
                                            let python_bin = 'pythonw'
                                        endif
                                    endif
                                    let cmd = [python_bin, '-W', 'ignore', s:cli_location]
                                    let cmd = cmd + ['--entity', heartbeat.entity]
                                    let cmd = cmd + ['--time', heartbeat.time]
                                    let cmd = cmd + ['--plugin', printf('vim/%d vim-wakatime/%s', v:version, s:VERSION)]
                                    if heartbeat.is_write
                                        let cmd = cmd + ['--write']
                                    endif
                                    if has_key(heartbeat, 'language')
                                        let cmd = cmd + ['--language', heartbeat.language]
                                    endif
                                    if extra_heartbeats != ''
                                        let cmd = cmd + ['--extra-heartbeats']
                                    endif
                            
                                    " overwrite shell
                                    let [sh, shellcmdflag, shrd] = [&shell, &shellcmdflag, &shellredir]
                                    if !s:IsWindows()
                                        set shell=sh shellredir=>%s\ 2>&1
                                    endif
                            
                                    if s:has_async
                                        let job = job_start([&shell, &shellcmdflag, s:JoinArgs(cmd)], { 'stoponexit': '', 'callback': {channel, output -> s:AsyncHandler(output, cmd)}})
                                        if extra_heartbeats != ''
                                            let channel = job_getchannel(job)
                                            call ch_sendraw(channel, extra_heartbeats . "\n")
                                        endif
                                    elseif s:nvim_async
                                        let job = jobstart([&shell, &shellcmdflag, s:JoinArgs(cmd)], { 'detach': 1, 'on_stdout': function('s:AsyncNeovimHandler'), 'on_stderr': function('s:AsyncNeovimHandler'), 'on_exit': function('s:AsyncNeovimHandler')})
                                        if extra_heartbeats != ''
                                            call jobsend(job, extra_heartbeats . "\n")
                                        endif
                                    elseif s:IsWindows()
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')', extra_heartbeats)
                                            else
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')')
                                            endif
                                        else
                                            exec 'silent !start /b cmd /c "' . s:JoinArgs(cmd) . ' > nul 2> nul"'
                                        endif
                                    else
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd), extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd))
                                            endif
                                        else
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd) . ' &', extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd) . ' &')
                                            endif
                                        endif
                                    endif
                            
                                    " restore shell
                                    let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                            
                                    let s:last_sent = localtime()
                            
                                    " need to repaint in case a key was pressed while sending
                                    if !s:has_async && !s:nvim_async && s:redraw_setting != 'disabled'
                                        if s:redraw_setting == 'auto'
                                            if s:last_sent - start_time > 0
                                                redraw!
                                            endif
                                        else
                                            redraw!
                                        endif
                                    endif
                            
                                    if s:is_debug_on && stdout != ''
                                        echoerr '[WakaTime] Heartbeat Command: ' . s:JoinArgs(cmd) . "\n[WakaTime] Error: " . stdout
                                    endif

FUNCTION  airline#extensions#ale#get_error()
Called 4 times
Total time:   0.000364
 Self time:   0.000027

count  total (s)   self (s)
    4   0.000363   0.000026   return airline#extensions#ale#get('error')

FUNCTION  <SNR>118_CreateCountDict()
Called 8 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
    8              0.000060     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  ctrlp#mrufiles#cachefile()
Called 1 time
Total time:   0.000581
 Self time:   0.000241

count  total (s)   self (s)
    1              0.000004 	if !exists('s:cadir') || !exists('s:cafile')
    1   0.000565   0.000229 		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
    1   0.000009   0.000005 		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
    1              0.000001 	en
    1              0.000001 	retu s:cafile

FUNCTION  <SNR>90_update_hg_branch()
Called 4 times
Total time:   0.000215
 Self time:   0.000215

count  total (s)   self (s)
                              " path argument is not actually used, so we don't actually care about a:1
                              " it is just needed, because update_git_branch needs it.
    4              0.000009   if s:has_lawrencium
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
    4              0.000013     let s:vcs_config['mercurial'].branch = ''
    4              0.000004   endif

FUNCTION  ale#events#QuitEvent()
Called 1 time
Total time:   0.000057
 Self time:   0.000043

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    1   0.000053   0.000039     call setbufvar(a:buffer, 'ale_quitting', ale#util#ClockMilliseconds())

FUNCTION  <SNR>91_ale_refresh()
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000010   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif

FUNCTION  <SNR>66_CursorHoldUpdate()
Called 2 times
Total time:   0.000088
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000007     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
                                endif
                            
    2   0.000067   0.000024     if !g:NERDTree.IsOpen()
    2              0.000003         return
                                endif
                            
                                " Do not update when a special buffer is selected
                                if !empty(&l:buftype)
                                    return
                                endif
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                call g:NERDTree.CursorToTreeWin()
                                call b:NERDTree.root.refreshFlags()
                                call NERDTreeRender()
                            
                                exec l:altwinnr . 'wincmd w'
                                exec l:winnr . 'wincmd w'

FUNCTION  airline#extensions#ale#get()
Called 8 times
Total time:   0.000836
 Self time:   0.000501

count  total (s)   self (s)
    8              0.000038   if !exists(':ALELint')
                                return ''
                              endif
                            
    8              0.000024   let is_err = a:type ==# 'error'
    8              0.000023   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
    8              0.000017   let is_err = a:type ==# 'error'
    8   0.000350   0.000063   let counts = ale#statusline#Count(bufnr(''))
    8              0.000025   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
    8              0.000050   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
    8              0.000023     let errors = counts.error + counts.style_error
    8              0.000025     let num = is_err ? errors : counts.total - errors
    8              0.000007   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
    8   0.000165   0.000117   return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)

FUNCTION  gitgutter#utility#set_buffer()
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000007   let s:bufnr = a:bufnr
    2              0.000029   let s:file = resolve(bufname(a:bufnr))

FUNCTION  airline#util#wrap()
Called 32 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
   32              0.000104   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   32              0.000044   return a:text

FUNCTION  <SNR>16_savetofile()
Called 1 time
Total time:   0.001190
 Self time:   0.000017

count  total (s)   self (s)
    1   0.001190   0.000017 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  <SNR>37_repo_dir()
Called 8 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    8              0.000073   return join([self.git_dir]+a:000,'/')

FUNCTION  <SNR>89_is_branch_empty()
Called 4 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    4              0.000040   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  ale#util#ClockMilliseconds()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000012     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  ctrlp#utils#mkdir()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000014 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    1              0.000001 	retu a:dir

FUNCTION  <SNR>90_update_branch()
Called 4 times
Total time:   0.002231
 Self time:   0.000624

count  total (s)   self (s)
    4              0.000309   let b:airline_fname_path = get(b:, 'airline_fname_path', exists("*fnamemodify") ? fnamemodify(resolve(@%), ":p:h") : expand("%:p:h"))
   12              0.000040   for vcs in keys(s:vcs_config)
    8   0.001730   0.000123     call {s:vcs_config[vcs].update_branch}(b:airline_fname_path)
    8              0.000043     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
    8              0.000007   endfor

FUNCTION  <SNR>113_StopCursorTimer()
Called 2 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000008     if s:cursor_timer != -1
                                    call timer_stop(s:cursor_timer)
                                    let s:cursor_timer = -1
                                endif

FUNCTION  <SNR>68_isDarwin()
Called 4 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    4              0.000015   if exists('s:is_darwin')
    4              0.000006     return s:is_darwin
                              endif
                            
                              if exists('g:WebDevIconsOS')
                                let s:is_darwin = g:WebDevIconsOS ==? 'Darwin'
                                return s:is_darwin
                              endif
                            
                              if has('macunix')
                                let s:is_darwin = 1
                                return s:is_darwin
                              endif
                            
                              if ! has('unix')
                                let s:is_darwin = 0
                                return s:is_darwin
                              endif
                            
                              if system('uname -s') ==# "Darwin\n"
                                let s:is_darwin = 1
                              else
                                let s:is_darwin = 0
                              endif
                            
                              return s:is_darwin

FUNCTION  ctrlp#utils#opts()
Called 1 time
Total time:   0.000126
 Self time:   0.000084

count  total (s)   self (s)
    1   0.000024   0.000016 	let s:lash = ctrlp#utils#lash()
    1   0.000030   0.000014 	let usrhome = $HOME . s:lash( $HOME )
    1              0.000005 	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
    1   0.000052   0.000034 	let cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
    1              0.000003 	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
    1              0.000002 	let s:cache_dir = cadir

FUNCTION  ctrlp#utils#lash()
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    3              0.000015 	retu &ssl || !exists('+ssl') ? '/' : '\'

FUNCTION  <SNR>37_sub()
Called 4 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
    4              0.000107   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  WebDevIconsGetFileTypeSymbol()
Called 4 times
Total time:   0.001001
 Self time:   0.001001

count  total (s)   self (s)
    4              0.000014   let appendArtifactFix = g:DevIconsAppendArtifactFix
    4              0.000007   if a:0 == 0
    4              0.000016     let fileNodeExtension = expand('%:e')
    4              0.000012     let fileNode = expand('%:t')
    4              0.000007     let isDirectory = 0
    4              0.000003   else
                                let fileNodeExtension = fnamemodify(a:1, ':e')
                                let fileNode = fnamemodify(a:1, ':t')
                                if a:0 > 1
                                  let isDirectory = a:2
                                else
                                  let isDirectory = 0
                                endif
                            
                                if a:0 == 3
                                  let appendArtifactFix = a:3
                                endif
                              endif
                            
    4              0.000010   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
    4              0.000012     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
    4              0.000015     let fileNodeExtension = tolower(fileNodeExtension)
    4              0.000012     let fileNode = tolower(fileNode)
                            
   40              0.000151     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
   36              0.000261       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
                                  endif
   36              0.000062     endfor
                            
    4              0.000016     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
    4              0.000020       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
                                  elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
                                  elseif isDirectory == 1
                                    let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
                                  endif
    4              0.000002     endif
                            
    4              0.000003   else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
                              endif
                            
                              " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
                              " actual font patcher)
    4              0.000007   if appendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
                              else
    4              0.000009     let artifactFix = ''
    4              0.000005   endif
                            
    4              0.000013   return symbol . artifactFix
                            

FUNCTION  airline#parts#paste()
Called 4 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    4              0.000015   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  gitgutter#utility#restore_shell()
Called 2 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000009   if has('unix')
    2              0.000010     if exists('s:shell')
    2              0.000012       let &shell = s:shell
    2              0.000011       let &shellcmdflag = s:shellcmdflag
    2              0.000010       let &shellredir = s:shellredir
    2              0.000002     endif
    2              0.000002   endif

FUNCTION  ctrlp#utils#cachedir()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002 	retu s:cache_dir

FUNCTION  <SNR>16_record()
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000006 	if s:locked | retu | en
    1              0.000005 	let bufnr = a:bufnr + 0
    1              0.000005 	let bufname = bufname(bufnr)
    1              0.000005 	if bufnr > 0 && !empty(bufname)
                            		cal filter(s:mrbs, 'v:val != bufnr')
                            		cal insert(s:mrbs, bufnr)
                            		cal s:addtomrufs(bufname)
                            	en

FUNCTION  airline#parts#readonly()
Called 4 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    4              0.000018   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
    4              0.000009     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  gitgutter#utility#setbufvar()
Called 4 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    4              0.000037   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
    4              0.000020   let dict[a:varname] = a:val
    4              0.000024   call setbufvar(a:buffer, 'gitgutter', dict)

FUNCTION  <SNR>118_GetCounts()
Called 8 times
Total time:   0.000192
 Self time:   0.000112

count  total (s)   self (s)
    8              0.000055     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
    8   0.000132   0.000052         return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
                                if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
                                return g:ale_buffer_info[a:buffer].count

FUNCTION  ale#engine#Cleanup()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
    1              0.000005     if get(v:, 'exiting', v:null) isnot v:null
                                    return
                                endif
                            
    1              0.000004     if !has_key(g:ale_buffer_info, a:buffer)
    1              0.000001         return
                                endif
                            
                                call ale#engine#RunLinters(a:buffer, [], 1)
                            
                                call remove(g:ale_buffer_info, a:buffer)

FUNCTION  airline#parts#spell()
Called 4 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
    4              0.000072   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
    4              0.000010   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
    4              0.000004   return ''

FUNCTION  ctrlp#utils#readfile()
Called 1 time
Total time:   0.001412
 Self time:   0.001412

count  total (s)   self (s)
    1              0.001279 	if filereadable(a:file)
    1              0.000121 		let data = readfile(a:file)
    1              0.000005 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    1              0.000001 		retu data
                            	en
                            	retu []

FUNCTION  airline#extensions#whitespace#check()
Called 4 times
Total time:   0.000643
 Self time:   0.000567

count  total (s)   self (s)
    4              0.000022   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
    4              0.000033   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
    4              0.000021   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                if index(checks, 'trailing') > -1
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
                              endif
    4   0.000100   0.000024   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>92_ws_refresh()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000013   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    2              0.000002     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>91_airline_ale_get_line_number()
Called 8 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    8              0.000012   if a:cnt == 0
    8              0.000009     return ''
                              endif
                            
                              let buffer       = bufnr('')
                              let problem_type = (a:type ==# 'error') ? 'E' : 'W'
                              let problems     = copy(ale#engine#GetLoclist(buffer))
                            
                              call filter(problems, 'v:val.bufnr is buffer && v:val.type is# problem_type')
                            
                              if empty(problems)
                                return ''
                              endif
                            
                              let open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . problems[0].lnum . close_lnum_symbol

FUNCTION  gitgutter#utility#bufnr()
Called 4 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    4              0.000009   return s:bufnr

FUNCTION  airline#parts#crypt()
Called 4 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    4              0.000030   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>16_mergelists()
Called 1 time
Total time:   0.002466
 Self time:   0.000459

count  total (s)   self (s)
    1   0.002023   0.000030 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    1              0.000361 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    1              0.000050 	let mrufs = s:mrufs + diskmrufs
    1   0.000031   0.000017 	retu s:chop(mrufs)

FUNCTION  <SNR>37_repo_head()
Called 4 times
Total time:   0.000879
 Self time:   0.000230

count  total (s)   self (s)
    4   0.000589   0.000050     let head = s:repo().head_ref()
                            
    4              0.000069     if head =~# '^ref: '
    4   0.000157   0.000047       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
    4              0.000009     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
    4              0.000006     return branch

FUNCTION  airline#extensions#keymap#status()
Called 4 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    4              0.000034   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
    4              0.000031     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  airline#extensions#branch#head()
Called 4 times
Total time:   0.002565
 Self time:   0.000150

count  total (s)   self (s)
    4              0.000017   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
    4   0.002265   0.000034   call s:update_branch()
    4   0.000222   0.000038   call s:update_untracked()
                            
    4              0.000024   if exists('b:airline_head') && !empty(b:airline_head)
    4              0.000006     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = {}
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads[vcs] = b:buffer_vcs_config[vcs].branch
                                endif
                              endfor
                            
                              for vcs in keys(heads)
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                let b:airline_head .= (len(heads) > 1 ? s:vcs_config[vcs].exe .':' : '') . s:format_name(heads[vcs])
                                let b:airline_head .= b:buffer_vcs_config[vcs].untracked
                              endfor
                            
                              if empty(heads)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
                              if has_key(heads, 'git') && !s:check_in_path()
                                let b:airline_head = ''
                              endif
                              let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
                              let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
                              return b:airline_head

FUNCTION  WebDevIconsGetFileFormatSymbol()
Called 4 times
Total time:   0.000204
 Self time:   0.000177

count  total (s)   self (s)
    4              0.000011   let fileformat = ''
    4              0.000007   let bomb = ''
                            
    4              0.000011   if (&bomb && g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol !=? '')
                                let bomb = g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol . ' '
                              endif
                            
    4              0.000008   if &fileformat ==? 'dos'
                                let fileformat = ''
                              elseif &fileformat ==? 'unix'
    4   0.000057   0.000030     if s:isDarwin()
    4              0.000008       let fileformat = ''
    4              0.000003     else
                                  let fileformat = ''
                                endif
    4              0.000006   elseif &fileformat ==? 'mac'
                                let fileformat = ''
                              endif
                            
                              " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
                              " actual font patcher)
    4              0.000011   let artifactFix = g:DevIconsArtifactFixChar
                            
    4              0.000014   return bomb . fileformat . artifactFix

FUNCTION  220()
Called 4 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    4              0.000019     if exists("t:NERDTreeBufName")
                                    return bufwinnr(t:NERDTreeBufName)
                                endif
                            
    4              0.000006     return -1

FUNCTION  221()
Called 4 times
Total time:   0.000076
 Self time:   0.000027

count  total (s)   self (s)
    4   0.000075   0.000026     return s:NERDTree.GetWinNum() != -1

FUNCTION  GitGutterGetHunkSummary()
Called 4 times
Total time:   0.000161
 Self time:   0.000042

count  total (s)   self (s)
    4   0.000157   0.000038   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 4 times
Total time:   0.000189
 Self time:   0.000080

count  total (s)   self (s)
    4   0.000184   0.000075   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#tabline#buflist#invalidate()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   unlet! s:current_buffer_list

FUNCTION  <SNR>37_can_diffoff()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000017   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>91_airline_ale_count()
Called 8 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    8              0.000019   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  <SNR>89_get_hunks_gitgutter()
Called 4 times
Total time:   0.000288
 Self time:   0.000084

count  total (s)   self (s)
    4   0.000088   0.000045   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
    4   0.000188   0.000027   return GitGutterGetHunkSummary()

FUNCTION  <SNR>147_lash()
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000033 	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''

FUNCTION  fugitive#head()
Called 4 times
Total time:   0.001127
 Self time:   0.000092

count  total (s)   self (s)
    4              0.000018   if !exists('b:git_dir')
                                return ''
                              endif
                            
    4   0.001095   0.000060   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  <SNR>89_get_hunks()
Called 4 times
Total time:   0.000484
 Self time:   0.000196

count  total (s)   self (s)
    4              0.000033   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
    4   0.000339   0.000051   return {b:source_func}()

FUNCTION  gitgutter#utility#exists_file()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000011   return filereadable(s:file)

FUNCTION  gitgutter#utility#is_file_buffer()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000021   return empty(getbufvar(s:bufnr, '&buftype'))

FUNCTION  gitgutter#utility#is_active()
Called 2 times
Total time:   0.000116
 Self time:   0.000084

count  total (s)   self (s)
    2   0.000113   0.000081   return g:gitgutter_enabled && !pumvisible() && gitgutter#utility#is_file_buffer() && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  airline#util#shorten()
Called 8 times
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
    8              0.000054   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
    8              0.000013     return a:text
                              endif

FUNCTION  <SNR>16_chop()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000011 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    1              0.000001 	retu a:mrufs

FUNCTION  <SNR>17_on_window_changed()
Called 1 time
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000005   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    1              0.000019   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
    1              0.000031   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    1              0.000001     return
                              endif
                              let g:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()

FUNCTION  airline#extensions#branch#get_head()
Called 4 times
Total time:   0.002699
 Self time:   0.000134

count  total (s)   self (s)
    4   0.002603   0.000038   let head = airline#extensions#branch#head()
    4              0.000025   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
    4              0.000023   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
    4              0.000043   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  airline#extensions#hunks#get_hunks()
Called 4 times
Total time:   0.000995
 Self time:   0.000511

count  total (s)   self (s)
    4              0.000016   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
    4              0.000097   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
    4   0.000518   0.000034   let hunks = s:get_hunks()
    4              0.000006   let string = ''
    4              0.000013   if !empty(hunks)
   16              0.000033     for i in [0, 1, 2]
   12              0.000052       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
   12              0.000096         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
   12              0.000010       endif
   12              0.000029     endfor
    4              0.000005   endif
    4              0.000011   let b:airline_hunks = string
    4              0.000010   let b:airline_changenr = b:changedtick
    4              0.000013   let s:airline_winwidth = winwidth(0)
    4              0.000006   return string

FUNCTION  gitgutter#utility#getbufvar()
Called 4 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    4              0.000035   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
    4              0.000016   if has_key(dict, a:varname)
    4              0.000010     return dict[a:varname]
                              else
                                if a:0
                                  return a:1
                                endif
                              endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 2 times
Total time:   0.000191
 Self time:   0.000162

count  total (s)   self (s)
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    2              0.000024     if mode() isnot# 'n'
                                    return
                                endif
                            
    2   0.000072   0.000043     call s:StopCursorTimer()
                            
    2              0.000024     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    2              0.000007     if l:pos != s:last_pos
                                    let l:delay = ale#Var(bufnr(''), 'echo_delay')
                            
                                    let s:last_pos = l:pos
                                    let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
                                endif

FUNCTION  <SNR>68_CursorHoldUpdate()
Called 2 times
Total time:   0.000066
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000005   if g:NERDTreeUpdateOnCursorHold != 1
                                return
                              endif
                            
    2   0.000049   0.000016   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    2              0.000002     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l.altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  airline#extensions#ale#get_warning()
Called 4 times
Total time:   0.000550
 Self time:   0.000051

count  total (s)   self (s)
    4   0.000549   0.000050   return airline#extensions#ale#get('warning')

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    4   0.002699   0.000134  airline#extensions#branch#get_head()
    4   0.002565   0.000150  airline#extensions#branch#head()
    1   0.002466   0.000459  <SNR>16_mergelists()
    4   0.002231   0.000624  <SNR>90_update_branch()
    1   0.001412             ctrlp#utils#readfile()
    4   0.001392   0.000265  <SNR>90_update_git_branch()
    1   0.001190   0.000017  <SNR>16_savetofile()
    1   0.001173   0.001153  ctrlp#utils#writecache()
    4   0.001127   0.000092  fugitive#head()
    4   0.001001             WebDevIconsGetFileTypeSymbol()
    4   0.000995   0.000511  airline#extensions#hunks#get_hunks()
    4   0.000879   0.000230  <SNR>37_repo_head()
    8   0.000836   0.000501  airline#extensions#ale#get()
    2   0.000823   0.000283  gitgutter#process_buffer()
    4   0.000643   0.000567  airline#extensions#whitespace#check()
    4   0.000629             airline#check_mode()
    1   0.000581   0.000241  ctrlp#mrufiles#cachefile()
    4   0.000550   0.000051  airline#extensions#ale#get_warning()
    4   0.000484   0.000196  <SNR>89_get_hunks()
    4   0.000416   0.000339  <SNR>37_repo_head_ref()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1              0.001412  ctrlp#utils#readfile()
    1   0.001173   0.001153  ctrlp#utils#writecache()
    4              0.001001  WebDevIconsGetFileTypeSymbol()
    4              0.000629  airline#check_mode()
    4   0.002231   0.000624  <SNR>90_update_branch()
    4   0.000643   0.000567  airline#extensions#whitespace#check()
    4   0.000995   0.000511  airline#extensions#hunks#get_hunks()
    8   0.000836   0.000501  airline#extensions#ale#get()
    1   0.002466   0.000459  <SNR>16_mergelists()
   28              0.000409  airline#util#append()
    4   0.000416   0.000339  <SNR>37_repo_head_ref()
    2   0.000823   0.000283  gitgutter#process_buffer()
    8              0.000279  <SNR>37_repo()
    4   0.001392   0.000265  <SNR>90_update_git_branch()
    1   0.000581   0.000241  ctrlp#mrufiles#cachefile()
   32              0.000234  airline#util#wrap()
    4   0.000879   0.000230  <SNR>37_repo_head()
    4              0.000215  <SNR>90_update_hg_branch()
    4              0.000203  airline#statusline()
    4   0.000484   0.000196  <SNR>89_get_hunks()

